<!doctype html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ØªØ·Ø¨ÙŠÙ‚ ÙŠØªÙƒÙ„Ù… Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (Ø¨Ø¯ÙˆÙ† Ø¨Ø§Ùƒ-Ø¥Ù†Ø¯)</title>
  <style>
    body { font-family: system-ui, Arial, sans-serif; margin: 24px; background: #0b1220; color:#e8eefc; }
    .card { max-width: 900px; margin: 0 auto; background: #121a2b; border: 1px solid #22304d; border-radius: 16px; padding: 18px; }
    h1 { margin: 0 0 10px; font-size: 22px; }
    textarea, input, select, button {
      width: 100%; box-sizing: border-box; border-radius: 12px; border: 1px solid #2a3a5f;
      padding: 12px; font-size: 16px; background: #0e1627; color: #e8eefc;
    }
    textarea { min-height: 120px; resize: vertical; }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-top: 12px; }
    .row3 { display:grid; grid-template-columns: 1fr 1fr 1fr; gap:12px; margin-top: 12px; }
    .btns { display:flex; gap:10px; flex-wrap: wrap; margin-top: 12px; }
    button { cursor:pointer; }
    button.primary { background: #2f66ff; border-color:#2f66ff; color:white; }
    button.danger { background: #ff3b3b; border-color:#ff3b3b; color:white; }
    .muted { color:#a9b7d6; font-size: 13px; line-height: 1.5; margin-top: 10px; }
    .pill { display:inline-block; padding:6px 10px; border-radius:999px; border:1px solid #2a3a5f; background:#0e1627; }
    .status { margin-top: 10px; display:flex; gap:10px; flex-wrap: wrap; align-items:center; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
  </style>
</head>
<body>
  <div class="card">
    <h1>ğŸ—£ï¸ ØªØ·Ø¨ÙŠÙ‚ ÙŠØªÙƒÙ„Ù… Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (ÙƒÙ„Ù‘Ù‡ Ø¯Ø§Ø®Ù„ Ø§Ù„Ù…ØªØµÙØ­)</h1>

    <label for="text">Ø§Ù„Ù†Øµ Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯ Ø£Ù† ÙŠÙ†Ø·Ù‚Ù‡ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚:</label>
    <textarea id="text" placeholder="Ø§ÙƒØªØ¨ Ù‡Ù†Ø§...">Ù…Ø±Ø­Ø¨Ø§Ù‹! Ø£Ù†Ø§ ØªØ·Ø¨ÙŠÙ‚ ÙŠØ¹Ù…Ù„ Ø¨Ø¯ÙˆÙ† Ø¨Ø§Ùƒ-Ø¥Ù†Ø¯ ÙˆØ£ØªÙƒÙ„Ù… Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©.</textarea>

    <div class="row">
      <div>
        <label for="voice">Ø§Ù„ØµÙˆØª (Voice):</label>
        <select id="voice"></select>
      </div>
      <div>
        <label for="dialect">Ù„ØºØ©/Ù„Ù‡Ø¬Ø© Ø§Ù„ØªØ¹Ø±Ù‘Ù Ø¹Ù„Ù‰ Ø§Ù„ÙƒÙ„Ø§Ù…:</label>
        <select id="dialect">
          <option value="ar-SA">ar-SA (Ø§Ù„Ø³Ø¹ÙˆØ¯ÙŠØ©)</option>
          <option value="ar-EG">ar-EG (Ù…ØµØ±)</option>
          <option value="ar-AE">ar-AE (Ø§Ù„Ø¥Ù…Ø§Ø±Ø§Øª)</option>
          <option value="ar-JO">ar-JO (Ø§Ù„Ø£Ø±Ø¯Ù†)</option>
          <option value="ar-LB">ar-LB (Ù„Ø¨Ù†Ø§Ù†)</option>
          <option value="ar-MA">ar-MA (Ø§Ù„Ù…ØºØ±Ø¨)</option>
          <option value="ar-DZ">ar-DZ (Ø§Ù„Ø¬Ø²Ø§Ø¦Ø±)</option>
          <option value="ar-TN">ar-TN (ØªÙˆÙ†Ø³)</option>
          <option value="ar-IQ">ar-IQ (Ø§Ù„Ø¹Ø±Ø§Ù‚)</option>
          <option value="ar-KW">ar-KW (Ø§Ù„ÙƒÙˆÙŠØª)</option>
        </select>
      </div>
    </div>

    <div class="row3">
      <div>
        <label for="rate">Ø§Ù„Ø³Ø±Ø¹Ø© (Rate): <span id="rateV" class="pill mono">1.0</span></label>
        <input id="rate" type="range" min="0.6" max="1.4" value="1.0" step="0.1" />
      </div>
      <div>
        <label for="pitch">Ø§Ù„Ø­Ø¯Ù‘Ø© (Pitch): <span id="pitchV" class="pill mono">1.0</span></label>
        <input id="pitch" type="range" min="0" max="2" value="1.0" step="0.1" />
      </div>
      <div>
        <label for="volume">Ø§Ù„ØµÙˆØª (Volume): <span id="volV" class="pill mono">1.0</span></label>
        <input id="volume" type="range" min="0" max="1" value="1.0" step="0.05" />
      </div>
    </div>

    <div class="btns">
      <button id="speak" class="primary">â–¶ï¸ Ø§Ù†Ø·Ù‚</button>
      <button id="stop" class="danger">â¹ï¸ Ø¥ÙŠÙ‚Ø§Ù</button>
      <button id="listen">ğŸ™ï¸ Ø§Ø³ØªÙ…Ø¹ (ØªØ­ÙˆÙŠÙ„ ÙƒÙ„Ø§Ù…ÙŠ Ø¥Ù„Ù‰ Ù†Øµ)</button>
      <button id="clear">ğŸ§¹ Ù…Ø³Ø­ Ø§Ù„Ù†Øµ</button>
    </div>

    <div class="status">
      <span class="pill">TTS: <span id="ttsStatus" class="mono">Ø¬Ø§Ù‡Ø²</span></span>
      <span class="pill">STT: <span id="sttStatus" class="mono">ØºÙŠØ± Ù†Ø´Ø·</span></span>
    </div>

    <p class="muted">
      Ù…Ù„Ø§Ø­Ø¸Ø§Øª Ø³Ø±ÙŠØ¹Ø©:
      <br>â€¢ Ù…ÙŠØ²Ø© Ø§Ù„Ø§Ø³ØªÙ…Ø§Ø¹ (Ø§Ù„Ù…ÙŠÙƒØ±ÙˆÙÙˆÙ†) ØªØ¹Ù…Ù„ ØºØ§Ù„Ø¨Ø§Ù‹ ÙÙŠ Chrome/Edge ÙˆØªØ­ØªØ§Ø¬ HTTPS Ø£Ùˆ localhost.
      <br>â€¢ Ø§Ù„Ø£ØµÙˆØ§Øª Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ø§Ù„Ù…ØªØ§Ø­Ø© ØªØ®ØªÙ„Ù Ø­Ø³Ø¨ Ù†Ø¸Ø§Ù… Ø§Ù„ØªØ´ØºÙŠÙ„ ÙˆØ§Ù„Ù…ØªØµÙØ­.
    </p>
  </div>

<script>
(() => {
  // ----- UI refs -----
  const $ = (id) => document.getElementById(id);
  const textEl = $("text");
  const voiceEl = $("voice");
  const dialectEl = $("dialect");
  const speakBtn = $("speak");
  const stopBtn = $("stop");
  const listenBtn = $("listen");
  const clearBtn = $("clear");
  const ttsStatus = $("ttsStatus");
  const sttStatus = $("sttStatus");

  const rateEl = $("rate"), pitchEl = $("pitch"), volumeEl = $("volume");
  const rateV = $("rateV"), pitchV = $("pitchV"), volV = $("volV");
  const syncRanges = () => {
    rateV.textContent = Number(rateEl.value).toFixed(1);
    pitchV.textContent = Number(pitchEl.value).toFixed(1);
    volV.textContent = Number(volumeEl.value).toFixed(2);
  };
  [rateEl, pitchEl, volumeEl].forEach(el => el.addEventListener("input", syncRanges));
  syncRanges();

  // ----- Speech Synthesis (TTS) -----
  const hasTTS = "speechSynthesis" in window && "SpeechSynthesisUtterance" in window;
  let voices = [];

  function populateVoices() {
    if (!hasTTS) {
      ttsStatus.textContent = "ØºÙŠØ± Ù…Ø¯Ø¹ÙˆÙ…";
      voiceEl.innerHTML = `<option>Ø§Ù„Ù…ØªØµÙØ­ Ù„Ø§ ÙŠØ¯Ø¹Ù… Ø§Ù„Ù†Ø·Ù‚</option>`;
      voiceEl.disabled = true;
      speakBtn.disabled = true;
      stopBtn.disabled = true;
      return;
    }

    voices = speechSynthesis.getVoices() || [];
    // Prefer Arabic voices first
    const arabic = voices.filter(v => (v.lang || "").toLowerCase().startsWith("ar"));
    const others = voices.filter(v => !(v.lang || "").toLowerCase().startsWith("ar"));

    const ordered = [...arabic, ...others];
    voiceEl.innerHTML = ordered.map((v, idx) => {
      const tag = (v.lang || "unknown");
      return `<option value="${idx}">${v.name} â€” ${tag}</option>`;
    }).join("");

    // Auto-select first Arabic voice if available
    if (arabic.length > 0) {
      const firstArabicIndex = ordered.indexOf(arabic[0]);
      voiceEl.value = String(firstArabicIndex);
      ttsStatus.textContent = "Ø¬Ø§Ù‡Ø² (ØµÙˆØª Ø¹Ø±Ø¨ÙŠ Ù…ØªÙˆÙØ±)";
    } else {
      ttsStatus.textContent = "Ø¬Ø§Ù‡Ø² (Ù„Ø§ ÙŠÙˆØ¬Ø¯ ØµÙˆØª Ø¹Ø±Ø¨ÙŠâ€”Ø³ÙŠÙØ³ØªØ®Ø¯Ù… Ø£Ù‚Ø±Ø¨ ØµÙˆØª Ù…ØªØ§Ø­)";
    }
  }

  // Some browsers load voices async
  if (hasTTS) {
    populateVoices();
    speechSynthesis.onvoiceschanged = populateVoices;
  }

  function speakArabic() {
    if (!hasTTS) return;
    const text = (textEl.value || "").trim();
    if (!text) return;

    // Stop anything currently speaking
    speechSynthesis.cancel();

    const u = new SpeechSynthesisUtterance(text);
    // Try to set Arabic; voice choice matters most.
    u.lang = "ar";

    const idx = Number(voiceEl.value);
    const all = voices.length ? voices : speechSynthesis.getVoices();
    if (all && all[idx]) u.voice = all[idx];

    u.rate = Number(rateEl.value);
    u.pitch = Number(pitchEl.value);
    u.volume = Number(volumeEl.value);

    u.onstart = () => (ttsStatus.textContent = "ÙŠØªÙƒÙ„Ù… Ø§Ù„Ø¢Ù†â€¦");
    u.onend = () => (ttsStatus.textContent = "Ø¬Ø§Ù‡Ø²");
    u.onerror = () => (ttsStatus.textContent = "Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù†Ø·Ù‚");

    speechSynthesis.speak(u);
  }

  function stopSpeaking() {
    if (!hasTTS) return;
    speechSynthesis.cancel();
    ttsStatus.textContent = "Ù…ÙˆÙ‚ÙˆÙ";
    setTimeout(() => (ttsStatus.textContent = "Ø¬Ø§Ù‡Ø²"), 300);
  }

  speakBtn.addEventListener("click", speakArabic);
  stopBtn.addEventListener("click", stopSpeaking);

  // ----- Speech Recognition (STT) -----
  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  const hasSTT = !!SpeechRecognition;
  let rec = null;
  let listening = false;

  function setupSTT() {
    if (!hasSTT) {
      listenBtn.disabled = true;
      sttStatus.textContent = "ØºÙŠØ± Ù…Ø¯Ø¹ÙˆÙ…";
      return;
    }
    rec = new SpeechRecognition();
    rec.continuous = true;
    rec.interimResults = true;

    rec.onstart = () => {
      listening = true;
      sttStatus.textContent = "ÙŠØ³ØªÙ…Ø¹â€¦";
      listenBtn.textContent = "ğŸ›‘ Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø§Ø³ØªÙ…Ø§Ø¹";
    };

    rec.onend = () => {
      listening = false;
      sttStatus.textContent = "ØºÙŠØ± Ù†Ø´Ø·";
      listenBtn.textContent = "ğŸ™ï¸ Ø§Ø³ØªÙ…Ø¹ (ØªØ­ÙˆÙŠÙ„ ÙƒÙ„Ø§Ù…ÙŠ Ø¥Ù„Ù‰ Ù†Øµ)";
    };

    rec.onerror = (e) => {
      sttStatus.textContent = "Ø®Ø·Ø£: " + (e.error || "unknown");
    };

    rec.onresult = (event) => {
      // Build final + interim
      let finalText = "";
      let interimText = "";
      for (let i = event.resultIndex; i < event.results.length; i++) {
        const res = event.results[i];
        const transcript = res[0].transcript;
        if (res.isFinal) finalText += transcript;
        else interimText += transcript;
      }

      // Put results into the textarea
      // If final text arrives, append it. Show interim at the end.
      const base = textEl.dataset.baseText ?? textEl.value;
      if (finalText) {
        const newBase = (base + (base.trim() ? "\n" : "") + finalText).trim();
        textEl.value = newBase;
        textEl.dataset.baseText = newBase;
      }
      if (interimText) {
        const stable = textEl.dataset.baseText ?? "";
        textEl.value = stable + "\n" + interimText;
      }
    };
  }

  setupSTT();

  function toggleListen() {
    if (!hasSTT || !rec) return;
    if (!listening) {
      // reset base buffer
      textEl.dataset.baseText = textEl.value.trim();
      rec.lang = dialectEl.value;  // e.g., ar-SA
      try { rec.start(); } catch (_) {}
    } else {
      rec.stop();
    }
  }

  listenBtn.addEventListener("click", toggleListen);

  clearBtn.addEventListener("click", () => {
    textEl.value = "";
    textEl.dataset.baseText = "";
    textEl.focus();
  });
})();
</script>
</body>
</html>

